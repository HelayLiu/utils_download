{
    "removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) returns (uint256)": [
        {
            "potential_checks": "deadline >= block.timestamp == False",
            "involved_variables": [
                "deadline",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) returns (uint256)": [
        {
            "potential_checks": "approveMax == False",
            "involved_variables": [
                "block.timestamp",
                "deadline",
                "value",
                "approveMax"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "deadline >= block.timestamp == False",
            "involved_variables": [
                "block.timestamp",
                "deadline",
                "value",
                "approveMax"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline)": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "deadline",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "deadline",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin == False",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "deadline",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline)": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "factory",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "amountIn",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "path[0] == WETH",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "factory",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "amountIn",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "IWETH(WETH).transfer(SolidlyV2Library.pairFor(factory,path[0],path[1]),amountIn)",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "factory",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "amountIn",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "factory",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "amountIn",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin == False",
            "involved_variables": [
                "path",
                "SafeMath",
                "amountOutMin",
                "factory",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "amountIn",
                "balanceBefore",
                "to",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        }
    ],
    "swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline)": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "amountOutMin",
                "WETH",
                "deadline",
                "amountOut",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "path[path.length - 1] == WETH",
            "involved_variables": [
                "path",
                "amountOutMin",
                "WETH",
                "deadline",
                "amountOut",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "amountOutMin",
                "WETH",
                "deadline",
                "amountOut",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "amountOut >= amountOutMin == False",
            "involved_variables": [
                "path",
                "amountOutMin",
                "WETH",
                "deadline",
                "amountOut",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        }
    ],
    "factory() returns (address)": [],
    "WETH() returns (address)": [],
    "addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) returns (uint256, uint256, uint256)": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "factory"
            ]
        },
        {
            "potential_checks": "reserveA == 0 && reserveB == 0 == False",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "factory"
            ]
        },
        {
            "potential_checks": "amountBOptimal <= amountBDesired == False",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "factory"
            ]
        },
        {
            "potential_checks": "amountAOptimal <= amountADesired",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "factory"
            ]
        },
        {
            "potential_checks": "amountAOptimal >= amountAMin == False",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "factory"
            ]
        }
    ],
    "addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) returns (uint256, uint256, uint256)": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "reserveA == 0 && reserveB == 0 == False",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "amountBOptimal <= amountBDesired == False",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "amountAOptimal <= amountADesired",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "amountAOptimal >= amountAMin",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "IWETH(WETH).transfer(pair,amountETH)",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "msg.value > amountETH == False",
            "involved_variables": [
                "amountAMin",
                "amountAOptimal",
                "amountBOptimal",
                "factory",
                "tokenB",
                "WETH",
                "amountBDesired",
                "deadline",
                "tokenA",
                "amountADesired",
                "msg.value",
                "amountETH",
                "pair",
                "block.timestamp",
                "reserveA",
                "reserveB"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        }
    ],
    "removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) returns (uint256, uint256)": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "amountBMin",
                "amountB",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "tokenA == token0 == False",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "amountBMin",
                "amountB",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "amountA >= amountAMin",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "amountBMin",
                "amountB",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "amountB >= amountBMin == False",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "amountBMin",
                "amountB",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "removeLiquidityETH(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) returns (uint256, uint256)": [
        {
            "potential_checks": "deadline >= block.timestamp == False",
            "involved_variables": [
                "deadline",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) returns (uint256, uint256)": [
        {
            "potential_checks": "approveMax == False",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "approveMax",
                "amountBMin",
                "amountB",
                "block.timestamp",
                "value"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "approveMax",
                "amountBMin",
                "amountB",
                "block.timestamp",
                "value"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "tokenA == token0 == False",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "approveMax",
                "amountBMin",
                "amountB",
                "block.timestamp",
                "value"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "amountA >= amountAMin",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "approveMax",
                "amountBMin",
                "amountB",
                "block.timestamp",
                "value"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "amountB >= amountBMin == False",
            "involved_variables": [
                "amountAMin",
                "amountA",
                "token0",
                "deadline",
                "tokenA",
                "approveMax",
                "amountBMin",
                "amountB",
                "block.timestamp",
                "value"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "removeLiquidityETHWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) returns (uint256, uint256)": [
        {
            "potential_checks": "approveMax == False",
            "involved_variables": [
                "block.timestamp",
                "deadline",
                "value",
                "approveMax"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "deadline >= block.timestamp == False",
            "involved_variables": [
                "block.timestamp",
                "deadline",
                "value",
                "approveMax"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) returns (uint256[])": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "amountOutMin",
                "path",
                "amounts",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "amounts[amounts.length - 1] >= amountOutMin",
            "involved_variables": [
                "amountOutMin",
                "path",
                "amounts",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "amountOutMin",
                "path",
                "amounts",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline) returns (uint256[])": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "amounts",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "amounts[0] <= amountInMax",
            "involved_variables": [
                "path",
                "amounts",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": []
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "amounts",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": []
        }
    ],
    "swapExactETHForTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline) returns (uint256[])": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "amountOutMin",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "path[0] == WETH",
            "involved_variables": [
                "path",
                "amountOutMin",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "amounts[amounts.length - 1] >= amountOutMin",
            "involved_variables": [
                "path",
                "amountOutMin",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "IWETH(WETH).transfer(SolidlyV2Library.pairFor(factory,path[0],path[1]),amounts[0])",
            "involved_variables": [
                "path",
                "amountOutMin",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "amountOutMin",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        }
    ],
    "swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline) returns (uint256[])": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "path[path.length - 1] == WETH",
            "involved_variables": [
                "path",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "amounts[0] <= amountInMax",
            "involved_variables": [
                "path",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp",
                "amountInMax"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        }
    ],
    "swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) returns (uint256[])": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "amountOutMin",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "path[path.length - 1] == WETH",
            "involved_variables": [
                "path",
                "amountOutMin",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "amounts[amounts.length - 1] >= amountOutMin",
            "involved_variables": [
                "path",
                "amountOutMin",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "amountOutMin",
                "amounts",
                "WETH",
                "deadline",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH"
            ]
        }
    ],
    "swapETHForExactTokens(uint256 amountOut, address[] path, address to, uint256 deadline) returns (uint256[])": [
        {
            "potential_checks": "deadline >= block.timestamp",
            "involved_variables": [
                "path",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "msg.value",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "path[0] == WETH",
            "involved_variables": [
                "path",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "msg.value",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "amounts[0] <= msg.value",
            "involved_variables": [
                "path",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "msg.value",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "IWETH(WETH).transfer(SolidlyV2Library.pairFor(factory,path[0],path[1]),amounts[0])",
            "involved_variables": [
                "path",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "msg.value",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "i < path.length - 1 == False",
            "involved_variables": [
                "path",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "msg.value",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        },
        {
            "potential_checks": "msg.value > amounts[0] == False",
            "involved_variables": [
                "path",
                "factory",
                "amounts",
                "WETH",
                "SolidlyV2Library",
                "deadline",
                "msg.value",
                "i",
                "block.timestamp"
            ],
            "descriptions": "",
            "references": [
                "WETH",
                "factory"
            ]
        }
    ],
    "quote(uint256 amountA, uint256 reserveA, uint256 reserveB) returns (uint256)": [],
    "getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut, address pair) returns (uint256)": [],
    "getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut, address pair) returns (uint256)": [],
    "getAmountsOut(uint256 amountIn, address[] path) returns (uint256[])": [],
    "getAmountsIn(uint256 amountOut, address[] path) returns (uint256[])": []
}